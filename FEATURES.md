# WhisperSubs 功能与优势

本文档说明本项目“要实现/已实现”的功能目标、关键特性与优势，方便统一认知与后续迭代。

## 目标与定位
- 作为 **原生 MPV C 插件**，在播放过程中实时生成字幕。
- **纯 Rust 实现**，避免 Lua 依赖与 FFI 复杂度。
- 面向长视频/网络流场景，追求 **实时性、稳定性与可控延迟**。

## 核心功能（已实现 + 正在完善）
- **实时语音识别**  
  - 支持持续转写，自动跟随播放进度。
  - 支持网络流缓存与本地文件路径（本地路径逻辑已具备，仍在完善边界体验）。
- **双语字幕自动翻译**  
  - 异步并发翻译，避免阻塞识别。
  - 识别与翻译**解耦**：识别结果即刻可用，翻译可延后补齐。
- **Seek/快进/后退自适应**  
  - 跨 chunk seek 会立即取消旧任务（Whisper / 翻译 / FFmpeg）。
  - 同一 chunk 内 seek 不打断，避免无谓抖动。
  - seek 回到已识别区间时，自动补翻译而不重做识别。
- **固定时间区间切分**  
  - 本地/网络各自独立的 chunk size。
  - 区间固定对齐（例如 00:00–00:15、00:15–00:30），便于管理与去重。
- **字幕文件管理**  
  - 本地文件：优先写入与媒体同目录同名 `.srt`；若路径不可写（如 `content://`），回退到临时目录。
  - 网络流：写入专用缓存目录（基于媒体标识哈希），重进流时可直接加载复用。
  - 统一 SRT 输出，内存中管理字幕并实时刷新。
  - 只保存主字幕文件，减少临时文件堆积。
- **字幕缓存与复用**  
  - 已生成字幕可复用，避免重复识别。
  - 翻译结果缓存，缺失翻译可在回到区间时自动补齐。
- **可配置运行时参数**  
  - TOML 配置 + 环境变量覆盖。
  - 线程数、语言、模型、翻译并发、超时等可控。
- **设备与后端**  
  - CPU / CUDA 选择与自动回退。

## 关键机制与特性
- **取消机制（保证 seek 响应速度）**
  - STT 后端使用 abort callback 直接中断推理。
  - FFmpeg 使用 interrupt callback 中断 I/O，并在解码循环中检查取消。
  - 翻译队列通过 generation 机制丢弃旧任务与结果。
- **分场景 chunk 策略**
  - 本地与网络模式分别使用独立的 chunk size。
  - 不再依赖“最短网络 chunk”，统一按固定区间推进。
- **低延迟策略**
  - 追赶模式（落后阈值自动跳转）。
  - 预读处理（lookahead），控制提前量上限。
- **可靠性与容错**
  - 超时保护（ffmpeg / ffprobe / stt / translate）。
  - 错误分级处理：取消不当作错误，避免误报。
  - 缓存与去重机制减少重复工作，提升稳定性。

## 优势
- **性能**：原生 Rust + 直接调用 MPV/FFmpeg/Whisper，低开销。
- **稳定性**：内存安全与显式错误处理，降低崩溃风险。
- **可控性**：关键路径可取消、可限时、可配置。
- **易部署**：单一动态库插件，集成到 MPV 即可使用。
- **扩展性**：模块清晰（audio / stt / translate / srt / plugin），便于新增功能。

## 下一步可选方向
- 本地文件模式体验完善（字幕保存路径策略等）。
- 更细粒度的字幕/翻译缓存策略与可视化统计。
- 更智能的句级去重与翻译质量优化。
